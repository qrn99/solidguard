import {
  BadRequestException,
  NotFoundException,
  UseGuards,
} from '@nestjs/common';
import { ExploitService } from './exploit.service';
import {
  CreateExploitRequestDto,
  ExploitResponseDto,
  SearchExploitsQueryDto,
  CreateExploitResponseDto,
  ExploitIdParamDto,
} from './dto';
import { InjectQueue } from '@nestjs/bull';
import { Queue } from 'bull';
import { SessionAuthGuard } from '../user/guard/session-auth.guard';
import { ContractService } from '../contract/contract.service';
import { UserId } from '../user/guard/user-id.decorator';
import { UserService } from '../user/user.service';
import validator from 'validator';
import { Resolver, Query, Mutation, Args } from '@nestjs/graphql';
import { Role } from '@prisma/client';
import { Roles } from '../user/guard/roles.decorator';
import { RolesGuard } from '../user/guard/roles.guard';

@Resolver()
export class ExploitResolver {
  constructor(
    @InjectQueue('exploitNotify')
    private readonly exploitNotifyQueue: Queue,
    private readonly exploitService: ExploitService,
    private readonly contractService: ContractService,
    private readonly userService: UserService
  ) {}

  @Query(() => ExploitResponseDto, { nullable: true })
  async getExploitById(
    @Args('expliotId') params: ExploitIdParamDto
  ): Promise<ExploitResponseDto> {
    const exploit = await this.exploitService.getExploit(params.exploitId);
    if (!exploit) {
      throw new NotFoundException('Exploit at the given id does not exist.');
    }
    const user = await this.userService.getUserById(exploit.authorUserId);
    return { ...exploit, authorName: user.name };
  }

  @Query(() => [ExploitResponseDto], { nullable: true })
  async searchExploitByName(
    @Args('page') pageNo: number,
    @Args('queryInfo') queryInfo: SearchExploitsQueryDto
  ): Promise<ExploitResponseDto[]> {
    const searchDto = {
      name: queryInfo.name ? queryInfo.name : '',
      pageNo,
    };
    if (searchDto.pageNo < 1 || !Number.isInteger(searchDto.pageNo)) {
      throw new BadRequestException('Page must be >= 1 and an integer.');
    }
    const exploits = await this.exploitService.searchExploitByName(searchDto);
    const exploitsDisplay: ExploitResponseDto[] = [];

    // merge authorNames with exploits
    for (let i = 0; i < exploits.length; i++) {
      const user = await this.userService.getUserById(exploits[i].authorUserId);
      exploitsDisplay[i] = { ...exploits[i], authorName: user.name };
    }

    if (!exploitsDisplay) {
      throw new NotFoundException({
        errorMessage: 'Cannot find any exploits with the given query.',
        data: [],
      });
    }
    return exploitsDisplay;
  }

  @UseGuards(SessionAuthGuard)
  @Query(() => [ExploitResponseDto], { nullable: true })
  async getUserExploits(
    @UserId() userId: string,
    @Args('page') page: number
  ): Promise<ExploitResponseDto[]> {
    if (page < 0) {
      throw new BadRequestException('Page must be >= 0.'); // should be >=1
    }
    const exploits = await this.exploitService.getUserExploit(userId, page);
    if (exploits.length == 0) {
      throw new NotFoundException({
        errorMessage: 'Cannot find any exploits with the given query.',
        data: [],
      });
    }
    const exploitsDisplay: ExploitResponseDto[] = [];
    const user = await this.userService.getUserById(exploits[0].authorUserId);
    for (let i = 0; i < exploits.length; i++) {
      exploitsDisplay[i] = { ...exploits[i], authorName: user.name };
    }

    return exploitsDisplay;
  }

  @UseGuards(SessionAuthGuard)
  @Mutation(() => CreateExploitResponseDto)
  async createExploit(
    @UserId() userId: string,
    @Args('createExploitRequest')
    createExploitRequestDto: CreateExploitRequestDto
  ): Promise<CreateExploitResponseDto> {
    const esInfo = {
      names: createExploitRequestDto.targetNames,
      addr: createExploitRequestDto.targetAddr,
    };

    // escape characters used for SQL injection
    const reqEscaped = {
      ...createExploitRequestDto,
      description: validator.escape(createExploitRequestDto.description),
    };

    // check if they are valid etherscan contracts
    if (!(await this.contractService.isValidEtherscanContracts(esInfo)))
      throw new BadRequestException('Not a valid smart contract target.');
    const createExploit = { ...reqEscaped, authorUserId: userId };
    return await this.exploitService.createExploit(createExploit); // err msges in console if the name is not unique
  }

  @UseGuards(SessionAuthGuard, RolesGuard)
  @Roles(Role.ADMIN)
  @Mutation(() => Boolean)
  async verifyExploit(@Args('exploitId') params: ExploitIdParamDto) {
    await this.exploitService.verifyExploit(params.exploitId);
    await this.exploitNotifyQueue.add({ exploitId: params.exploitId });
    return true;
  }
}
